<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <title>HiFi Audio API Example: Bots</title>
</head>

<body style="width: 100%; height: 100%; margin: 0; padding: 0;">
    <div class="console" style="z-index: 1; background-color: #efefef; padding: 10px; pointer-events: none; position: fixed; left: 0; top: 60px; width: 260px; font-family: monospace; font-size: 12px;">
        <div class="console-log-empty" style="padding: 5px; border: 1px solid #EFEFEF; display: block; width: fit-content;"></div>
    </div>
    <canvas class="thecanvas" style="position:fixed; right: 0; top: 0;"></canvas>
    <p class="example-description" style="position: fixed; left: 0; width: 100%; text-align: center;">Click the connect button to setup the audio nodes.<br>Drag the listener around to perceive spatialization<br>Right click to change orientation</p>
    <button class="triggerButton" style="cursor: pointer; font-size: 18px; background-color: #000000; color: white; width: 280px; top: 0; left: 0; height: 60px; margin: 0; position: fixed;"></button>
    <script src="https://hifi-spatial-audio-api.s3-us-west-2.amazonaws.com/releases/latest/HighFidelityAudio-latest.js"></script>
    <script src="https://hifi-spatial-audio-api.s3-us-west-2.amazonaws.com/releases/latest/HighFidelityControls-latest.js"></script>
    <script>
        const RADIANS_TO_DEGREES = 57.2958;
        // This is the JWT associated with "luis-2 stack space".
        const HIFI_AUDIO_JWT = "";
        const SoundNodeType = {
            NODE: 0,
            EMITTER: 1,
            RECEIVER: 2,
            BOT: 3
        };

        const ActionType = {
            DEFAULT: 0,
            LOOKAT: 1,
            TALK: 2,
            MOTION: 3
        };

        const MotionType = {
            LINEAR: 0,
            EASE_IN: 1,
            EASE_OUT: 2,
            EASE_IN_OUT: 3
        };

        const TaskType = {
            ACTION: 0,
            CALLBACK: 1
        };

        // Class that manages the physics loop
        // Steps are based on the system's requestAnimationFrame
        class PhysicsLoop {
            constructor() {
                this.deltaTimeSec = 0;
                this.previousTime = 0;
                this.onStep = {};
                this.isRunning = false;
            }
            
            addOnStepCback(name, cback) {
                this.onStep[name] = cback;
            }

            removeOnStepCback(name) {
                if (this.onStep.hasOwnProperty(name)) {
                    delete this.onStep[name];
                }
            }

            start() {
                this.isRunning = true;
                this._startPhysicsLoop();
            }
            
            stop() {
                this.isRunning = false;
            }

            _updateDeltaTime() {
                let timeNow = Date.now();
                this.deltaTimeSec = (timeNow - this.previousTime) / 1000.0;
                this.previousTime = timeNow;
            }

            _startPhysicsLoop() {
                this._updateDeltaTime();
                Object.entries(this.onStep).forEach(entry => {
                    let [name, cback] = entry;
                    cback.call(this, this.deltaTimeSec);
                });
                if (this.isRunning) {
                    window.requestAnimationFrame(this._startPhysicsLoop.bind(this));
                }        
            }
        }
        // Some helper functions for render and coordenates conversion on the 2d canvas
        class CanvasHelper {
            static finishPath(ctx, color, width) {
                ctx[(width !== undefined) ? "strokeStyle" : "fillStyle"] = color;
                ctx[(width !== undefined) ? "lineWidth" : ""] = width;
                ctx[(width !== undefined) ? "stroke" : "fill"].call(ctx);
            }
            // Compact function to render circles filled or stroked
            static renderCircle(ctx, x, y, radius, from, to, color, width) {
                ctx.beginPath();
                ctx.arc(x, y, radius, from, to, false);
                CanvasHelper.finishPath(ctx, color, width);
            }
            // Compact function to render polygons filled or stroked
            static renderPolygon(ctx, points, color, width) {
                ctx.beginPath();
                points.forEach((point, i) => {
                    ctx[i === 0 ? "moveTo" : "lineTo"].call(ctx, point[0], point[1]);
                });
                CanvasHelper.finishPath(ctx, color, width);
            }
            // Render text 
            static renderText(ctx, x, y, text, color, size, family) {
                family = family ? family : "console";
                ctx.font = `${size}px ${family}`;
                ctx.fillStyle = color;
                ctx.fillText(text, x, y);
            }
            // World coordenates to canvas conversion
            static worldToCanvasCoords(canvasWidth, canvasHeight, coords, offset, zoom) {
                let relPos = { x: coords.x - offset.x, y: coords.y - offset.y };
                let canvasPos = { x: 0.5 * canvasWidth - relPos.x / zoom, y: 0.5 * canvasHeight - relPos.y / zoom };
                return canvasPos;
            }
            // Canvas coordenates to world conversion
            static canvasToWorldCoords(canvasWidth, canvasHeight, coords, offset, zoom) {
                let newLocPos = { x: (coords.x - 0.5 * canvasWidth) * zoom, y: (coords.y - 0.5 * canvasHeight) * zoom, z: 0.0 };
                let npos = { x: offset.x - newLocPos.x, y: offset.y - newLocPos.y, z: offset.z - newLocPos.z };
                return npos;
            }
        }
        // Base class to render the node on the canvas
        class Renderable2D {
            constructor(config) {
                this.position = Object.assign({}, config.position);
                this.orientation = config.orientation; // radians
                this.radius = config.radius;
                this.name = config.name;
                this.color = config.color;
                this.selected = false;
                this.hover = false;                
            }

            isPointInside(worldPoint) {
                // Simple collision detection for node selection
                let distVec = { x: worldPoint.x - this.position.x, y: worldPoint.y - this.position.y };
                let distance = Math.sqrt(distVec.x * distVec.x + distVec.y * distVec.y);
                return distance < this.radius;
            }
            // Get a point located one unit in front of node
            getLookingAtPoint() {
                let angle = this.orientation - 0.5 * Math.PI;
                return { x: this.position.x - Math.cos(angle), y: this.position.y - Math.sin(angle) };
            }
            // Get the look at angle to a certain point
            getLookAtAngle(targetPos) {
                let dir = { x: targetPos.x - this.position.x, y: targetPos.y - this.position.y };
                return Math.atan2(dir.y, dir.x) - 0.5 * Math.PI;
            }
            // Render loop
            render(canvas, ctx, offset, zoom) {
                let canvasPos = CanvasHelper.worldToCanvasCoords(canvas.scrollWidth, canvas.scrollHeight, this.position, offset, zoom);
                // Let child classes implement their own method
                ctx.translate(canvasPos.x, canvasPos.y);
                ctx.rotate(this.orientation)
                this.renderNode(ctx, canvasPos, zoom);
                if (this.hover || this.selected) {
                    this.renderSelect(ctx, canvasPos, zoom);
                }
                ctx.rotate(-this.orientation);
                ctx.translate(-canvasPos.x, -canvasPos.y);
            }

            renderNode(ctx, position, zoom) {
                // Default method to render nodes
                CanvasHelper.renderCircle(ctx, 0, 0, this.radius / zoom, 0, 2.0 * Math.PI, this.color );
            }

            renderSelect(ctx, position, zoom) {
                // Render default selection effect
                CanvasHelper.renderCircle(ctx, 0, 0, (this.radius / zoom) + 4, 0, 2.0 * Math.PI, this.selected ? '#FF0000' : '#CCCCCC', 4);
            }
        }
        // Simple class to handle the node's connection, position and orientation
        class SoundNode extends Renderable2D {
            constructor(config) {
                super(config);
                this.mixerPosition = new HighFidelityAudio.Point3D({ x: -this.position.x, y: this.position.z, z: -this.position.y });
                this.mixerOrientation = new HighFidelityAudio.OrientationEuler3D({ "pitchDegrees": 0, "yawDegrees": -RADIANS_TO_DEGREES * this.orientation, "rollDegrees": 0 });
                this.hifiCommunicator = null;
                this.stream = null;
                this.type = SoundNodeType.NODE;
                this.volume = null;
                this.connectResponse = null;
            }
            // If the node is connected, its id will be the visit id hash provided by the server
            getId() {
                return this.connectResponse && this.connectResponse.success ? this.connectResponse.audionetInitResponse.visit_id_hash : null;
            }
            
            updateData(position, orientation) {
                if (position) {
                    this.position.x = position.x;
                    this.position.y = position.y;
                    this.position.z = position.z;
                    // We need to convert the position sent to the mixer
                    this.mixerPosition.x = -position.x;
                    this.mixerPosition.y = position.z;
                    this.mixerPosition.z = -position.y;
                }
                if (orientation) {
                    this.orientation = orientation;
                    this.mixerOrientation.yawDegrees = -RADIANS_TO_DEGREES * orientation;
                }
                this.sendUpdatedData();
            }

            sendUpdatedData(name) {
                if (this.hifiCommunicator) {
                    // Send the converted position and orientation to the mixer
                    let response = this.hifiCommunicator.updateUserDataAndTransmit({
                        position: this.mixerPosition,
                        orientationEuler: this.mixerOrientation
                    });
                }
            }
            // Volume data can be used to render the node
            updateReceivedData(data) {
                this.volume = data.volumeDecibels !== null ? data.volumeDecibels : this.volume;
            }
            
            onConnectionStateChanged(newConnectionState) {
                console.log(`New High Fidelity connection for: ${this.name} state: ${newConnectionState}`);
            }
            
            async connect() {
                console.log(`Connecting Receiver: ` + this.name + ` to High Fidelity Audio API Servers...`);
                this.hifiCommunicator = new HighFidelityAudio.HiFiCommunicator({
                    initialHiFiAudioAPIData: new HighFidelityAudio.HiFiAudioAPIData({
                        position: this.mixerPosition,
                        orientationEuler: this.mixerOrientation
                    }),
                    onConnectionStateChanged: this.onConnectionStateChanged.bind(this),
                });
                if (this.stream) {
                    await this.hifiCommunicator.setInputAudioMediaStream(this.stream, false);
                }
                try {
                    this.connectResponse = await this.hifiCommunicator.connectToHiFiAudioAPIServer(HIFI_AUDIO_JWT, null, HIFI_STACK);
                    console.log(`Call to \`connectToHiFiAudioAPIServer()\` for: ${this.name} succeeded! Response:\n${JSON.stringify(this.connectResponse)}`);
                    return this.connectResponse.success;
                } catch (e) {
                    console.error(`Call to \`connectToHiFiAudioAPIServer()\` for: ${this.name} failed! Error:\n${e}`);
                    this.connectResponse = null;
                    return false;
                }
            }

            async disconnect() {
                console.log(`Disconnecting Emitter: ${this.name} from High Fidelity Audio API Servers...`);
                let disconnectStatus = await this.hifiCommunicator.disconnectFromHiFiAudioAPIServer();
                this.connectResponse = null;
                console.log(`Disconnected status for ${this.name} : ${disconnectStatus}`);
            }
        }
        // SoundNode without input stream.
        class SoundReceiver extends SoundNode {
            constructor(config, onDataReceived) {
                super(config);
                this.type = SoundNodeType.RECEIVER;
                this.onDataReceived = onDataReceived ? onDataReceived : () => {};
            }
            renderNode(ctx, position, zoom) {
                // Create a sound cone pointing forward
                CanvasHelper.renderPolygon(ctx, [[0, 0], [1000, -1000], [-1000, -1000]], "#FAFAFF");
                // Render first 10 circles around the receiver every meter. Undo rotation first.
                ctx.rotate(-this.orientation);
                for (let i = 1; i < 11; i++) {
                    let radius = i / zoom;
                    CanvasHelper.renderCircle(ctx, 0, 0, radius, 0, 2.0 * Math.PI, this.color + "AA", 1);
                    CanvasHelper.renderText(ctx, radius, 0, `${i}m`, this.color, 15);
                }
                ctx.rotate(this.orientation);
                super.renderNode(ctx, position, zoom);
            }
            
            async connect() {
                if (await super.connect()) {
                    let outputAudioElem = document.createElement('audio');
                    outputAudioElem.srcObject = this.hifiCommunicator.getOutputAudioMediaStream();
                    // We must call `play()` here because certain browsers won't autoplay this stream as we expect.
                    outputAudioElem.play();
                    // This will get only volume updates for all Users (including ourselves).
                    let userDataSubscription = new HighFidelityAudio.UserDataSubscription({
                        "components": [ HighFidelityAudio.AvailableUserDataSubscriptionComponents.VolumeDecibels ],
                        "callback": (data) => { this.onDataReceived(data); }
                    });
                    this.hifiCommunicator.addUserDataSubscription(userDataSubscription);
                    return true;
                }
                return false;
            }
        }
        class FileAudioStream {
            constructor(gain) {
                this.stream = null;
                this.mediaElement = null;
                this.fileName = null;
                this.gain = gain;
            }
            async createStreamFromAudioFile(filename, onFinishPlaying) {
                if (this.fileName === filename) {
                    resolve(this.mediaElement);
                }
                let loadAudioFile = new Promise(resolve => {
                    let audioElem = document.createElement('audio');
                    audioElem.setAttribute('src', filename);
                    audioElem.addEventListener("loadeddata", (e) => {
                        resolve(e.target);
                    });
                    audioElem.addEventListener('ended',function(){
                        if (onFinishPlaying) {
                            onFinishPlaying();
                        }
                        
                    }.bind(this), false);
                });
                // Wait until the audio file is loaded
                this.mediaElement = await loadAudioFile;
                
                // Create a media element from audio context
                var ac = new AudioContext();
                let audioElementSource = ac.createMediaElementSource(this.mediaElement);
                var dest = ac.createMediaStreamDestination();
                
                // Setup a gain control
                var volume = ac.createGain();
                volume.connect(dest);
                volume.gain.value = this.gain;
                audioElementSource.connect(volume);

                // Return the input stream
                this.stream = dest.stream;
                return this.stream;
            }
        }

        // SoundNode with input stream from an audio file
        class SoundEmitter extends SoundNode {
            constructor(config, gain) {
                super(config);
                this.type = SoundNodeType.EMITTER;
                this.fileStream = new FileAudioStream(gain);
                this.emitting = false;
            }

            async prepareAudioFile(fileName, onFinishedEmitting) {
                this.stream = await this.fileStream.createStreamFromAudioFile(fileName, () => {
                    this.emitting = false;
                    if (onFinishedEmitting) {
                        onFinishedEmitting();
                    }
                });
                await this.hifiCommunicator.setInputAudioMediaStream(this.stream, false);
            }

            async prepareAndPlayAudioFile(fileName, onFinishedEmitting) {
                await this.prepareAudioFile(fileName, onFinishedEmitting);
                this.emit();
            }

            emit() {
                this.fileStream.mediaElement.play();
                this.emitting = true;
            }
        }

        // Basic action for bots
        class Action {
            constructor(name) {
                this.name = name;
                this.type = ActionType.DEFAULT;
                this.duration = 0;
                this.timeLapse = 0;
                this.delay = 0;
                this.active = false;
            }

            update(node, deltaTime) {
                if (this.active) {
                    let lastTime = this.timeLapse;
                    this.timeLapse += deltaTime;
                    if (this.timeLapse < this.duration) {
                        if (this.compute && this.timeLapse > 0) {
                            if (lastTime <= 0 && this.onActionActive) {
                                this.onActionActive(node);
                            }
                            this.compute(node);
                        }
                    } else {
                        this.active = false;
                        if (this.onActionTimeout) {
                            this.onActionTimeout(node);
                         }
                    }
                }
            }

            start(node) {
                // The action will be computed when timeLapse > 0
                this.timeLapse = -this.delay;
                this.active = true;       
                if (this.onActionStart) {
                    this.onActionStart(node);
                }                
            }

        }
        // Specific action to control position of bots
        class MotionAction extends Action {
            constructor(name, motionType) {
                super(name);
                this.type = ActionType.MOTION;
                this.initialPosition = null;
                this.finalPosition = null;
                this.motionType = motionType;
            }

            static getEasedValue(type, value) {
                switch (type) {
                    case MotionType.EASE_IN:
                        // Ease in cubic
                        return value * value * value;
                        break;
                    case MotionType.EASE_OUT:
                        // Ease out cubic
                        return (--value) * value * value + 1;
                        break;
                    case MotionType.EASE_IN_OUT:
                        // Ease in cubic
                        return value < 0.5 ? 4 * value * value * value : (value - 1) * (2 * value - 2) * (2 * value - 2) + 1;
                        break;
                    default:
                        return value;
                        break;
                }
            }

            compute(node) {
                let ratio = this.timeLapse / this.duration;
                let easeRatio = MotionAction.getEasedValue(this.motionType, ratio);
                node.position.x = this.initialPosition.x + (this.finalPosition.x - this.initialPosition.x) * easeRatio;
                node.position.y = this.initialPosition.y + (this.finalPosition.y - this.initialPosition.y) * easeRatio;
                node.position.z = this.initialPosition.z + (this.finalPosition.z - this.initialPosition.z) * easeRatio;
            }
            
            setData(data) {
                this.initialPosition = data.from;
                this.finalPosition = data.to;
                this.duration = data.duration;
                this.delay = data.delay;
                this.motionType = data.type;
            }

            onActionTimeout(node) {
                node.position = this.finalPosition;
                this.onActionEnded(node, this);
            }

            start(node, onActionEnded) {
                this.onActionEnded = onActionEnded;
                super.start(node);
            }
        }
        // Specific action to control bot orientation. Look at point controlled by a MotionAction.
        class LookAtAction extends MotionAction {
            constructor(name, motionType) {
                super(name, motionType);
                this.lookAtNode = { position: {x: 0, y: 0, z: 0 } };
                this.type = ActionType.LOOKAT;
            }
            setData(data) {
                super.setData(data);
                this.lookAtNode.x = data.from.x;
                this.lookAtNode.y = data.from.y;
            }
            compute(node) {
                super.compute(this.lookAtNode);
                node.updateData(node.position, node.getLookAtAngle(this.lookAtNode.position));
            }
            onActionTimeout(node) {
                super.onActionTimeout(this.lookAtNode);
            }
        }
        // Specific action to triggers audio file playing
        class TalkAction extends Action {
            constructor(name, fileName) {
                super(name);
                this.type = ActionType.TALK;
                this.fileName = fileName;
            }
            async onActionTimeout(node) {
                if (node.type === SoundNodeType.BOT || node.type === SoundNodeType.EMITTER) {
                    await node.prepareAndPlayAudioFile(this.fileName, () => {
                        this.onActionEnded(node, this);
                    });;
                }
            }
            setData(data) {
                this.duration = 0;
                this.delay = data.delay;
            }
            start(node, onActionEnded) {
                this.onActionEnded = onActionEnded;
                super.start(node);
            }
        }
        // Class that manages actions to control bots' behavior
        class TaskManager{
            constructor(meetingPoints, meetingRadius) {
                // Define the talking action based on the available audio files 
                this.talkActionNames = ["hi", "bye", "lead", "follow", "deep", "answer1", "answer2"];
                this.motionActionName = "Move";
                this.meetingPoints = meetingPoints;
                this.meetingRadius = meetingRadius;
                this.taskQueue = [];
                this.bots = {};
                this.meetingIdx = 0;
                this.forceMeetingPoint = null;
            }
            addBot(bot) {
                // Setup the same actions from every bot
                bot.addAction(this.motionActionName, ActionType.MOTION, { motionType: MotionType.EASE_IN_OUT });
                bot.addAction(this.lookAtActionName, ActionType.LOOKAT, { motionType: MotionType.EASE_IN_OUT });
                this.talkActionNames.forEach(actionName => {
                    bot.addAction(`Say_${actionName}`, ActionType.TALK, { fileName: `./audio/${bot.name}_${actionName}.mp3`});
                })
                this.bots[bot.getId()] = bot;
            }
            addMeetingPoint(point) {
                this.meetingPoints.push(point);
            }
            // Computes a set of random points around a meeting point where bots will end up
            static get2DRandomDataAround(origin, radius, count) {              
                let data = {pos: [], rot: []};
                for (let i = 0; i < count; i++) {
                    let angle = (Math.random() / count) + 2.0 * Math.PI * i  / count;
                    data.rot.push(angle);
                    data.pos.push({x: origin.x + radius * Math.cos(angle), y: origin.y + radius * Math.sin(angle), z: origin.z});
                }
                data.pos = data.pos.sort( () => .5 - Math.random() );
                return data;
            }
            // Handle the task queue
            update(deltaTime) {
                if (this.taskQueue.length > 0) {
                    let task = this.taskQueue[0];
                    if (task.type == TaskType.ACTION) {
                        if (!task.triggered && this.bots[task.botId]) {
                            this.bots[task.botId].triggerAction(task.name, task.data, () => {
                                this.taskQueue.shift();
                            });
                            task.triggered = true;
                        }
                    } else if (task.type == TaskType.CALLBACK) {
                        this.taskQueue.shift();
                        task.cback();
                    }

                }
                Object.keys(this.bots).forEach(id => {
                    this.bots[id].update(deltaTime);
                });
            }
            startConversation() {
                // Find a leader and start a conversation. One question by the leader and random responses
                let ids = Object.keys(this.bots);
                let leaderId = ids[Math.floor(Math.random() * ids.length)]; // Random leader
                this.addActionToQueue(leaderId, "Say_deep", { delay: 0 });
                ids.forEach(id => {
                    let isLeader = id === leaderId;
                    if (!isLeader && Math.random() < 0.25) { // 25% chance for this bot to trigger a random response
                        let answerIdx = Math.ceil(0.5 + Math.random());
                        this.addActionToQueue(id, `Say_answer${answerIdx}`, { delay: 0 });
                    }
                });
                this.addCallbackToQueue(() => { this.moveToNextMeetingPoint(); });
            }
            addCallbackToQueue(cback) {
                this.taskQueue.push({ type: TaskType.CALLBACK, cback: cback });
            }
            addActionToQueue(botId, actionName, actionData) {
                let taskData = { type: TaskType.ACTION, name: actionName, botId: botId, data: actionData, triggered: false };
                this.taskQueue.push(taskData);
            }
            // Bots will move around the canvas following a leader. Talk for a while on the point and then move to another point.
            moveToNextMeetingPoint() {
                this.meetingIdx = this.meetingIdx + 1 < this.meetingPoints.length ? this.meetingIdx + 1 : 0;
                let currentMeetingPoint = this.forceMeetingPoint ? Object.assign({}, this.forceMeetingPoint) : this.meetingPoints[this.meetingIdx];
                if (this.forceMeetingPoint) {
                    this.forceMeetingPoint = null;
                }
                let ids = Object.keys(this.bots);
                let newMeetingData = TaskManager.get2DRandomDataAround(currentMeetingPoint, this.meetingRadius, ids.length);
                let newMeetingPositions = newMeetingData.pos;
                // Let's choose a leader to move to the next meeting point
                let leaderId = ids[Math.floor(Math.random() * ids.length)];
                this.addActionToQueue(leaderId, "Say_lead", { delay: 0 });
                ids.forEach((id, i) => {
                    let bot = this.bots[id];
                    let isLeader = id === leaderId;
                    let actionDelay = isLeader ? 0 : i + 2.0 * Math.random();
                    let moveActionData = { 
                        from: Object.assign({}, bot.position), // From current position
                        to: newMeetingPositions[i], // Random position around the new meeting point
                        duration: 6.0, 
                        delay: actionDelay, 
                        type: MotionType.EASE_IN_OUT 
                    };
                    let shouldStay = false;
                    if (!isLeader) {
                        shouldStay = Math.random() < 0.15; // 15% chance to not move yet and say bye
                        if (shouldStay) {
                            this.addActionToQueue(id,"Say_bye", { delay: 0 });
                        } else if (Math.random() < 0.25) { // 25% change to respond to the leader's move
                            this.addActionToQueue(id, "Say_follow", { delay: 0 });
                        }
                    }
                    moveActionData.delay = shouldStay ? 10.0 : moveActionData.delay;
                    bot.triggerAction(this.motionActionName, moveActionData, () => {});
                    let lookAtActionData = Object.assign({}, moveActionData);
                    lookAtActionData.from = Object.assign({}, bot.getLookingAtPoint());
                    lookAtActionData.to = Object.assign({},currentMeetingPoint);
                    lookAtActionData.delay = moveActionData.delay * 0.5;
                    lookAtActionData.duration = moveActionData.duration + moveActionData.delay * 0.5;
                    bot.triggerAction(this.lookAtActionName, lookAtActionData, () => {});
                });
                this.addCallbackToQueue(() => { this.startConversation(); });
            }

            reset() {
                this.bots = {};
                this.taskQueue = [];
            }
        }
        // A SoundEmitter with some functions to handle actions and custom rendering
        class Bot extends SoundEmitter {
            constructor(config, gain) {
                super(config, gain);
                this.type = SoundNodeType.BOT;
                this.actions = {};
            }
            addAction(name, type, actionData) {
                if (type === ActionType.TALK) {
                    this.actions[name] = new TalkAction(name, actionData.fileName);
                } else if (type === ActionType.MOTION) {
                    this.actions[name] = new MotionAction(name, actionData.motionType);
                } else if (type === ActionType.LOOKAT) {
                    this.actions[name] = new LookAtAction(name, actionData.motionType);
                }
            }
            triggerAction(name, actionData, onActionEnded) {
                if (this.actions[name]) {
                    this.actions[name].setData(actionData);
                    this.actions[name].start(this, onActionEnded ? onActionEnded : () => {});
                }
            }
            update(deltaTime) {
                Object.keys(this.actions).forEach(name => {
                    this.actions[name].update(this, deltaTime);
                });
                this.updateData(this.position, this.orientation);
            }
            // Override renderNode function to for custom rendering for bots 
            renderNode(ctx, position, zoom) {
                // Compute volume ratio
                let volumeRatio = ((this.volume ? this.volume : -120.0) + 120.0) / 120.0;
                let radius = (this.radius / zoom);
                // Render a transparent circular area for the bot's visor 
                CanvasHelper.renderCircle(ctx, 0, 0, 0.95 * radius, 0, 2.0 * Math.PI, "#00000015");
                // Render a circular area that represents volume
                CanvasHelper.renderCircle(ctx, 0, 0, volumeRatio * 1.2 * radius, 0, 2.0 * Math.PI, this.color + "55");
                // Render a partial, thick arc for the main body 
                CanvasHelper.renderCircle(ctx, 0, 0, 0.4 * radius, -0.35, Math.PI + 0.35, this.color + "EE", radius);
                // Close the gap with a smaller circular area
                CanvasHelper.renderCircle(ctx, 0, 0, 0.55 * radius, 0, 2.0 * Math.PI, this.color);
            }
        }
        // Class will create the listener and bots and it will manage its behaviour
        class App {
            constructor(config) {
                this.config = config;
                this.physicsLoop = new PhysicsLoop();
                this.taskManager = null;
                this.soundNodes = {};
                this.receiverId = null;
                this.zoomAmount = 0.01; // Define the scale for how the world is displayed on the canvas
                this.selectedNodeId = null;
                this.hoveredNodeId = null;
                this.canvas = null;
                this.triggerButton = null;
                this.consoleElement = null;
                this.physicsLoop.addOnStepCback("drawCanvas", () => {
                    this.redraw();
                });
                this.physicsLoop.addOnStepCback("updateTask", (deltaTimeSec) => {
                    if (this.taskManager) {
                        this.taskManager.update(deltaTimeSec);
                    }
                });
            }

            setupUI(canvas, triggerButton, consoleElement) {
                this.canvas = canvas;
                this.triggerButton = triggerButton;
                this.consoleElement = consoleElement;
                // To add/remove event listener with the right context we need to bind them first
                this.connectNodesBinded = this.connectNodes.bind(this);
                this.disconnectNodesBinded = this.disconnectNodes.bind(this);
                this.triggerButton.addEventListener("click", this.connectNodesBinded, false);
                this.triggerButton.innerHTML = `Click to Connect`;
                window.addEventListener('resize', this.onResizeCanvas.bind(this), false);
                window.addEventListener('load', this.onResizeCanvas.bind(this), false);
                // Setup the canvas to receive control events
                let hifiControls = new HighFidelityControls.HiFiControls({ mainAppElement: this.canvas });
                hifiControls.onLeftDrag = this.onLeftDrag.bind(this);
                hifiControls.onRightDrag = this.onRightDrag.bind(this);
                hifiControls.onCanvasMove = this.onCanvasMove.bind(this);
                hifiControls.onCanvasDown = this.onCanvasDown.bind(this);
                this.physicsLoop.start();
            }

            async connectNodes() {
                // Create new task manager
                this.taskManager = new TaskManager(this.config.MEETING_POINTS, this.config.MEETING_RADIUS);
                // Compute random points around the first meeting point for bot's initial positions
                let botRandomData = TaskManager.get2DRandomDataAround(this.taskManager.meetingPoints[0], this.taskManager.meetingRadius, 4);
                // Data configuration for all nodes base on type
                let nodeData = [
                    {name: "Listener", radius: 0.25, color: "#AFAAFF", position: this.config.SPAWN_POINT, orientation: 0, type: SoundNodeType.RECEIVER},
                    {name: "Allison", radius: 0.25, color: "#FF00FF", position: botRandomData.pos[0], orientation: botRandomData.rot[0], type: SoundNodeType.BOT},
                    {name: "Henry", radius: 0.25, color: "#00FFFF", position: botRandomData.pos[1], orientation:botRandomData.rot[1], type: SoundNodeType.BOT},
                    {name: "Kevin", radius: 0.25, color: "#0000FF", position: botRandomData.pos[2], orientation: botRandomData.rot[2], type: SoundNodeType.BOT},
                    {name: "Lisa", radius: 0.25, color: "#00FF00", position: botRandomData.pos[3], orientation: botRandomData.rot[3], type: SoundNodeType.BOT}
                ];
                
                // Clear the console log and reset trigger button status
                this.displayLog("", true);
                this.triggerButton.disabled = true;
                this.triggerButton.innerHTML = `wait...`;

                for (let i = 0; i < nodeData.length; i++) {
                    let node = null;
                    if (nodeData[i].type == SoundNodeType.BOT) {
                        node = new Bot(nodeData[i], this.config.TRACKS_GAIN);
                    } else if (nodeData[i].type == SoundNodeType.RECEIVER) { 
                        // When the receiver gets data from the server we update nodes 
                        let onDataReceived = (dataArray) => {
                            dataArray.forEach(data => {
                                if (this.soundNodes[data.hashedVisitID]) {
                                    this.soundNodes[data.hashedVisitID].updateReceivedData(data);
                                }
                            });
                        }
                        node = new SoundReceiver(nodeData[i], onDataReceived);
                    }
                    if (node) {
                        if (await node.connect()) {
                            let nodeId = node.getId();
                            this.displayLog(`Node "${nodeData[i].name}" connected.`);
                            this.soundNodes[nodeId] = node;
                            if (node.type === SoundNodeType.RECEIVER) {
                                this.receiverId = nodeId;
                            } else if (node.type === SoundNodeType.BOT) {
                                // Add bot to the task manager
                                this.taskManager.addBot(node);
                            }
                        } else {
                            this.displayLog(`Node "${nodeData[i].name}" error connecting.`);
                        }
                    }
                }
                // Start bot actions
                this.taskManager.moveToNextMeetingPoint();
                // Reset trigger button status
                this.triggerButton.disabled = false;
                this.triggerButton.innerHTML = `Disconnect`;
                this.triggerButton.removeEventListener('click', this.connectNodesBinded, false);
                this.triggerButton.addEventListener('click', this.disconnectNodesBinded, false);
                this.displayLog(`Bots ready!`);
            }

            async disconnectNodes() {
                this.triggerButton.disabled = true;
                this.triggerButton.innerHTML = `wait...`;
                let ids = Object.keys(this.soundNodes);
                for (let i = 0; i < ids.length; i++) {
                    let id = ids[i];
                    await this.soundNodes[id].disconnect();
                    this.displayLog(`Node "${this.soundNodes[id].name}" disconnected.`);
                    delete this.soundNodes[id];
                };
                this.taskManager = null;
                // Reset triggerButton
                this.triggerButton.disabled = false;
                this.triggerButton.innerHTML = `Connect`;
                this.triggerButton.removeEventListener('click', this.disconnectNodesBinded, false);
                this.triggerButton.addEventListener('click', this.connectNodesBinded, false);
            }

            displayLog(text, clear) {
                let newLog = document.querySelector(".console-log-empty").cloneNode();
                if (clear) {
                    this.consoleElement.innerHTML = "";
                    newLog.innerHTML = "";
                    this.consoleElement.appendChild(newLog);
                } else {
                    newLog.innerHTML = text;
                    this.consoleElement.appendChild(newLog);
                }
            }

            redraw() {
                let ctx = this.canvas.getContext('2d');
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                // Call render method for all nodes
                Object.keys(this.soundNodes).forEach(id => {
                    this.soundNodes[id].render(this.canvas, ctx, this.config.SPAWN_POINT, this.zoomAmount);
                });
            }

            findNodeOnCanvas(position, isSelection) {
                // Compute world position based on the canvas point and search for a node
                let foundId = null;
                let worldPos = CanvasHelper.canvasToWorldCoords(this.canvas.scrollWidth, this.canvas.scrollHeight, position, this.config.SPAWN_POINT, this.zoomAmount);
                Object.keys(this.soundNodes).forEach(id => {
                    if (!foundId && this.soundNodes[id].isPointInside(worldPos)) {
                        // Node found. Set this node as the selected one
                        foundId = id;
                        this.soundNodes[id][(isSelection ? "selected" : "hover")] = true;
                    } else {
                        this.soundNodes[id][(isSelection ? "selected" : "hover")] = false;
                    }
                });
                return foundId;
            }

            onLeftDrag(e) {
                // Compute the world position based on the control event
                let worldPos = CanvasHelper.canvasToWorldCoords(this.canvas.scrollWidth, this.canvas.scrollHeight, {x: e.clientX, y: e.clientY}, this.config.SPAWN_POINT, this.zoomAmount);
                if (this.selectedNodeId && this.soundNodes[this.selectedNodeId]) {
                    let selectedNode = this.soundNodes[this.selectedNodeId];
                    // Update node base on the computed position
                    if (selectedNode.type === SoundNodeType.RECEIVER) {
                        selectedNode.updateData(worldPos, selectedNode.orientation);
                        this.taskManager.forceMeetingPoint = worldPos;
                    }
                }
            }
            onRightDrag(e) { 
                // Compute the world position based on the control event
                let worldPos = CanvasHelper.canvasToWorldCoords(this.canvas.scrollWidth, this.canvas.scrollHeight, {x: e.clientX, y: e.clientY}, this.config.SPAWN_POINT, this.zoomAmount);
                if (this.soundNodes[this.receiverId]) {
                    this.soundNodes[this.receiverId].updateData(null, this.soundNodes[this.receiverId].getLookAtAngle(worldPos));
                }
            }

            onCanvasMove(e) {
                let id = this.findNodeOnCanvas({x: e.clientX, y: e.clientY}, false);
                if (this.hoveredNodeId != id) {
                    // update the mouse icon if we are hovering a node
                    this.canvas.style.cursor = id ? "pointer" : "default";
                    this.hoveredNodeId = id;
                }
            }

            onCanvasDown(e) {
                const MOUSE_RIGHT_BUTTON = 2;
                if (e.button != MOUSE_RIGHT_BUTTON) {
                    if (this.selectedNodeId) {
                        // consoleElem.children[selectedNodeIdx].style.borderColor = "#EFEFEF";
                    }
                    this.selectedNodeId = this.findNodeOnCanvas({x: e.clientX, y: e.clientY}, true);
                    if (this.selectedNodeId > -1) {
                        // consoleElem.children[selectedNodeIdx].style.borderColor = "#FF0000"; 
                    }
                } else {
                    if (this.selectedNodeId && this.soundNodes[this.selectedNodeId] && this.soundNodes[this.selectedNodeId].type === SoundNodeType.RECEIVER) {
                        let targetPos = CanvasHelper.canvasToWorldCoords(this.canvas.scrollWidth, this.canvas.scrollHeight, {x: e.clientX, y: e.clientY}, this.config.SPAWN_POINT, this.zoomAmount);
                        this.soundNodes[this.selectedNodeId].updateData(null, this.soundNodes[this.selectedNodeId].getLookAtAngle(targetPos));
                    }
                }
            }

            onResizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.zoomAmount = 0.005 * 1280 / this.canvas.height;
            }
        }

        HighFidelityAudio.HiFiLogger.setHiFiLogLevel(HighFidelityAudio.HiFiLogLevel.Debug);
        let SPAWN_POINT = {x: 0, y: 0, z: 0};

        let APP_CONFIG = {
            SPAWN_POINT : SPAWN_POINT, // Initial position for the receiver
            MEETING_POINTS : [ // Points around the spawn point as meeting points for the bots
                {x: SPAWN_POINT.x - 1.5, y: SPAWN_POINT.y - 1.5, z: SPAWN_POINT.z}, 
                {x: SPAWN_POINT.x + 1.5, y: SPAWN_POINT.y - 1.5, z: SPAWN_POINT.z},
                {x: SPAWN_POINT.x + 1.5, y: SPAWN_POINT.y + 1.5, z: SPAWN_POINT.z},
                {x: SPAWN_POINT.x - 1.5, y: SPAWN_POINT.y + 1.5, z: SPAWN_POINT.z}
            ],
            MEETING_RADIUS : 0.75,
            TRACKS_GAIN : 0.4, // The volume for all tracks
        }
        let app = new App(APP_CONFIG);
        let canvasElement = document.querySelector('.thecanvas');
        let triggerButton = document.querySelector(`.triggerButton`);
        let consoleElement = document.querySelector(".console");
        app.setupUI(canvasElement, triggerButton, consoleElement);

    </script>
</body>

</html>